# -*- coding: utf-8 -*-
"""Copy of DoubleScrambling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mjxjl6nbwLqmpYmqZqwxf0SnJTcyLHpE

## **INSTALL AND IMPORT MODULES**
"""

!pip uninstall crypto
!pip uninstall pycryptodome
!pip install pycryptodome

!pip install cryptography

!pip install qrcode

!pip install stepic

"""## **SENDER END**"""

from hashlib import sha256
import base64
from Crypto import Random
from Crypto.Cipher import AES
import pandas as pd
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
from PIL import Image
import stepic

"""## **KEY GENERATION**"""

def gen_key():
    private_key = rsa.generate_private_key(
        public_exponent=65537, key_size=2048, backend=default_backend())

    public_key = private_key.public_key()
    return private_key, public_key


def save_pvkey(pk, filename):
    pem = pk.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption()
    )
    with open(filename, 'wb') as pem_out:
        pem_out.write(pem)

def save_pukey(pk, filename):
    pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    with open(filename, 'wb') as pem_out:
        pem_out.write(pem)

private_key, public_key = gen_key()

save_pvkey(private_key, 'private_key')
save_pukey(public_key, 'public_key')
print("private key and public key generated.")

def getSum(n):

    sum = 0
    for digit in str(n):
      sum += int(digit)
    return sum

graduation_year=int(input("Enter your graduation year:"))
favorite_number=int(input("Enter your favorite number(1-10)"))
a=getSum(graduation_year)
print(a)
attribute=a*favorite_number
print(attribute)

"""# **DNA CRYPTO**"""

DNA_data = { "words":["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W",
                   "X","Y","Z"," ",",",".",":","0","1","2","3","4","5","6","7","8","9"],
            "DNA_code": ["CGA","CCA","GTT","TTG","GGC","GGT","TTT","CGC","ATG","AGT","AAG","TGC","TCC","TCT","GGA","GTG",
                         "AAC","TCA","ACG","TTC","CTG","CCT","CCG","CTA","AAA","CTT","ACC","TCG","GAT","GCT","ACT","TAG",
                         "ATA","GCA","GAG","AGA","TTA","ACA","AGG","GCG"]
           }

DNA_df = pd.DataFrame.from_dict(DNA_data)
#print(DNA_df)

file_name = input("Enter file name").strip()
message = ""
try:
  with open(file_name) as f:
    message = " ".join([l.rstrip("\n") for l in f])

  DNA_crypto_message = ""
  word = message.upper()

  for i in word:
       DNA_crypto_message+= str(DNA_df.loc[ DNA_df['words'] == i , 'DNA_code' ].iloc[0])

  print(DNA_crypto_message)
except Exception as e:
  print(e)

key = input("Enter your key: ")
key=key.upper()
key=bytes(key,'utf-8')
key_message = key.decode()
DNA_key = ""
word = key_message.upper()


for j in word:
    DNA_key+= str(DNA_df.loc[ DNA_df['words'] == j , 'DNA_code' ].iloc[0])

print(DNA_key)

import random

def random_scramble(input_str,input_key):
    # Create a list of unique characters in the input string
    char_list = list(set(input_str))
    char1_list= list(set(input_key))

    # Shuffle the list to create a random mapping
    random.shuffle(char_list)
    random.shuffle(char1_list)

    # Create a dictionary to store the mapping
    mapping = {}
    mapping1 ={}
    for i, char in enumerate(char_list):
        mapping[char] = chr(i + attribute)

    for j, char in enumerate(char1_list):
        mapping1[char] = chr(j + attribute)

    # Use the mapping to substitute the characters in the input string
    scrambled_str = ''.join([mapping[char] for char in input_str])
    scrambled_key = ''.join([mapping1[char] for char in input_key])


    return (scrambled_str,scrambled_key,mapping,mapping1)


# Example usage
input_str = DNA_crypto_message
print("input:",input_str)
input_key=DNA_key
print("Actual key: ",input_key)
scrambled_str,scrambled_key, mapping,mapping1 = random_scramble(input_str,input_key)
print("Scrambled string , Scrambled key", scrambled_str,scrambled_key)

"""# **BLOWFISH CRYPTO**"""

from Crypto.Cipher import Blowfish
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes
import timeit


def encrypt(plaintext, key):
    # Generate a random IV (initialization vector)
    iv = get_random_bytes(Blowfish.block_size)

    # Create the Blowfish cipher object
    cipher = Blowfish.new(key, Blowfish.MODE_CBC, iv)

    # Encrypt the plaintext
    padded_plaintext = pad(plaintext, Blowfish.block_size)
    ciphertext = cipher.encrypt(padded_plaintext)

    # Concatenate the IV and ciphertext and return the result
    return iv + ciphertext


# Test the encryption and decryption functions

plaintext = bytes(scrambled_str,'utf-8')

ciphertext = encrypt(plaintext, key)
print(key)


print('Plaintext:', plaintext)
print('Ciphertext:', ciphertext)

print(timeit.timeit(lambda: encrypt(plaintext, key), number=100))

"""# **DIGITAL SIGNATURE**"""

def load_pvkey(filename):
    with open(filename, 'rb') as pem_in:
        pemlines = pem_in.read()

    private_key = load_pem_private_key(pemlines, None, default_backend())
    return private_key

message = ciphertext
private_key = load_pvkey("private_key")
signature = private_key.sign(message, padding.PSS(mgf=padding.MGF1(hashes.SHA256()),
                                                  salt_length=padding.PSS.MAX_LENGTH),hashes.SHA256())
# signature

import qrcode
# generating a QR code using the make() function
qr_img = qrcode.make(scrambled_key)
# saving the image file
qr_img.save("qr-img.jpg")

"""TARGET END

"""

from hashlib import sha256
import base64
from Crypto import Random
from Crypto.Cipher import AES
import pandas as pd
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
from PIL import Image
import stepic

"""# **VERIFY DIGITAL SIGNATURE**"""

def load_pukey(filename):
    with open(filename, 'rb') as pem_in:
        pemlines = pem_in.read()
    public_key = load_pem_public_key(pemlines, default_backend())
    return public_key

public_key = load_pukey("public_key")
try:
    public_key.verify(signature, message, padding.PSS(mgf=padding.MGF1(hashes.SHA256()),
                                                  salt_length=padding.PSS.MAX_LENGTH),hashes.SHA256())
    print(message)
except InvalidSignature:
    print('Invalid!')

def random_descramble(scrambled_str, mapping):
    # Reverse the mapping to create a decryption key
    decryption_key = {value: key for key, value in mapping.items()}

    # Use the decryption key to substitute the characters in the scrambled string
    descrambled_str = ''.join([decryption_key[char] for char in scrambled_str])

    return descrambled_str

QR_input=input()
# descrambled_str = random_descramble(scrambled_str, mapping)
# print("Descrambled string:", descrambled_str)
descrambled_key = random_descramble(QR_input, mapping1)
print("Descrambled key:", descrambled_key)

"""# **DNA DECODING**"""

DNA_data = { "words":["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W",
                   "X","Y","Z"," ",",",".",":","0","1","2","3","4","5","6","7","8","9"],
            "DNA_code": ["CGA","CCA","GTT","TTG","GGC","GGT","TTT","CGC","ATG","AGT","AAG","TGC","TCC","TCT","GGA","GTG",
                         "AAC","TCA","ACG","TTC","CTG","CCT","CCG","CTA","AAA","CTT","ACC","TCG","GAT","GCT","ACT","TAG",
                         "ATA","GCA","GAG","AGA","TTA","ACA","AGG","GCG"]
           }

DNA_df = pd.DataFrame.from_dict(DNA_data)

DNA_decrytpted_key = descrambled_key

l = [DNA_decrytpted_key[i:i+3] for i in range(0, len(DNA_decrytpted_key), 3)]

original_key = ""
for i in l:
    original_key+= str(DNA_df.loc[ DNA_df['DNA_code'] == i , 'words' ].iloc[0])
print("The secret key is: ",original_key)

"""# **BLOWFISH DECODING**"""

from Crypto.Cipher import Blowfish
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

def decrypt(ciphertext, key):
    # Extract the IV and ciphertext
    iv = ciphertext[:Blowfish.block_size]
    ciphertext = ciphertext[Blowfish.block_size:]

    # Create the Blowfish cipher object
    cipher = Blowfish.new(key, Blowfish.MODE_CBC, iv)

    # Decrypt the ciphertext and unpad the result
    padded_plaintext = cipher.decrypt(ciphertext)
    plaintext = unpad(padded_plaintext, Blowfish.block_size)

    # Return the plaintext
    return plaintext

# Test the encryption and decryption functions
key = original_key
key= key.encode()

# ciphertext = encrypt(plaintext, key)
decrypted_text = (decrypt(message, key))
decrypted_text1=decrypted_text.decode()

# print('Plaintext:', plaintext)
# print('Ciphertext:', ciphertext)
print('Decrypted text:', decrypted_text1)

def random_descramble(scrambled_str, mapping):
    # Reverse the mapping to create a decryption key
    decryption_key = {value: key for key, value in mapping.items()}

    # Use the decryption key to substitute the characters in the scrambled string
    descrambled_str = ''.join([decryption_key[char] for char in scrambled_str])

    return descrambled_str

descrambled_str = random_descramble(decrypted_text1, mapping)
print("Descrambled string:", descrambled_str)

"""# **DNA DECODING**"""

DNA_data = { "words":["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W",
                   "X","Y","Z"," ",",",".",":","0","1","2","3","4","5","6","7","8","9"],
            "DNA_code": ["CGA","CCA","GTT","TTG","GGC","GGT","TTT","CGC","ATG","AGT","AAG","TGC","TCC","TCT","GGA","GTG",
                         "AAC","TCA","ACG","TTC","CTG","CCT","CCG","CTA","AAA","CTT","ACC","TCG","GAT","GCT","ACT","TAG",
                         "ATA","GCA","GAG","AGA","TTA","ACA","AGG","GCG"]
           }

DNA_df = pd.DataFrame.from_dict(DNA_data)
DNA_decrytpted_str = descrambled_str

l = [DNA_decrytpted_str[i:i+3] for i in range(0, len(DNA_decrytpted_str), 3)]

original_message = ""
for i in l:
    original_message+= str(DNA_df.loc[ DNA_df['DNA_code'] == i , 'words' ].iloc[0])
print("The secret message is: ",original_message.lower())